/* 1.your name            joohye Son
2.the assignment number   3
3.the course name         CS230
4.the term                Spring 2019 */

#include "Color.h"
#include "Shader.h"
#include "glCheck.h"
#include "glew.h"
#include <cassert>
#include <iostream>
#include "glm/glm.hpp"

#pragma comment(lib, "glew32.lib")

		Shader::Shader(const std::string& vertex_shader_source_code, const std::string& fragment_shader_source_code)
		{
			LoadFromSource(vertex_shader_source_code, fragment_shader_source_code);
		}

		bool Shader::LoadFromSource(const std::string& vertex_shader_source_code, const std::string& fragment_shader_source_code)
		{
			GLuint program = glCreateProgram();
			glCheck(program);
			handleToShader = program;

			const char* vertex = vertex_shader_source_code.c_str();
			GLuint vshader = glCreateShader(GL_VERTEX_SHADER);
			glCheck(vshader);
			GLint vertex_compiled;

			glCheck(glShaderSource(vshader, 1, &vertex, NULL));
			glCheck(glCompileShader(vshader));
			glCheck(glGetShaderiv(vshader, GL_COMPILE_STATUS, &vertex_compiled));
			glCheck(glAttachShader(program, vshader));

			if (vertex_compiled != GL_TRUE)
			{
				GLsizei log_length = 0;
				glCheck((glGetShaderInfoLog(vshader, 1024, &log_length, NULL)));
				glCheck(glDeleteShader(vshader));
				return false;
			}

			const char* fragment = fragment_shader_source_code.c_str();
			GLuint fshader = glCreateShader(GL_FRAGMENT_SHADER);
			glCheck(fshader);
			GLint fragment_compiled;

			glCheck(glShaderSource(fshader, 1, &fragment, NULL));
			glCheck((glCompileShader(fshader)));
			glCheck(glGetShaderiv(fshader, GL_COMPILE_STATUS, &fragment_compiled));
			glCheck(glAttachShader(program, fshader));

			if (fragment_compiled != GL_TRUE)
			{
				GLsizei log_length = 0;
				glCheck(glGetShaderInfoLog(fshader, 1024, &log_length, NULL));
				glCheck(glDeleteShader(fshader));
				return false;
			}

			GLint program_linked;
			glCheck(glLinkProgram(program));
			glCheck(glGetProgramiv(program, GL_LINK_STATUS, &program_linked));

			if (program_linked != GL_TRUE)
			{
				GLsizei log_length = 0;
				glCheck(glGetProgramInfoLog(program, 1024, &log_length, NULL));
				return false;
			}

			glCheck(glUseProgram(program));

			return true;
		}

		void Shader::SendUniformVariable(const std::string& variable_name, const glm::mat3& affine_matrix) noexcept
		{
			GLfloat Affine_Matrix[9];
			Affine_Matrix[0] = affine_matrix[0][0];
			Affine_Matrix[1] = affine_matrix[0][1];
			Affine_Matrix[2] = affine_matrix[0][2];
			Affine_Matrix[3] = affine_matrix[1][0];
			Affine_Matrix[4] = affine_matrix[1][1];
			Affine_Matrix[5] = affine_matrix[1][2];
			Affine_Matrix[6] = affine_matrix[2][0];
			Affine_Matrix[7] = affine_matrix[2][1];
			Affine_Matrix[8] = affine_matrix[2][2];
			glCheck(glUniformMatrix3fv(GetUniformLocation(variable_name), 1, GL_FALSE, Affine_Matrix));
		}

		void Shader::SendUniformVariable(const std::string& variable_name, float number) noexcept
		{
			glCheck(glUniform1f(GetUniformLocation(variable_name), number));
		}

		void Shader::SendUniformVariable(const std::string& variable_name, int number) noexcept
		{
			glCheck(glUniform1i(GetUniformLocation(variable_name), number));
		}

		void Shader::SendUniformVariable(const std::string& variable_name, Color4f color) noexcept
		{
			glCheck(glUniform4f(GetUniformLocation(variable_name), color.red, color.blue, color.green, color.alpha));
		}

		void Shader::Select(const Shader& shader) noexcept
		{
			glCheck(glUseProgram(shader.handleToShader));
		}

		void Shader::SelectNothing() noexcept
		{
			glCheck(glUseProgram(0));
		}

		int Shader::GetUniformLocation(const std::string& name) noexcept
		{
			const GLchar* LocationName = name.c_str();
			GLint Location = glGetUniformLocation(handleToShader, LocationName);
			glCheck(Location);
			return Location;
		}

		void Shader::Delete() noexcept
		{
			glCheck(glDeleteShader(handleToShader));
		}